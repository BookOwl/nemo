include!("grammar.rs"); // auto-generated by lalrpop

#[cfg(test)]
mod tests {
    use super::*;
    use ast::{Expr, Op, Statement};

    fn s(x: &str) -> String {
        String::from(x)
    }

    #[test]
    fn test_parsing_number() {
        let expected = Box::new(Expr::Number(22));
        assert_eq!(parse_Expr("22").unwrap(), expected);
        assert_eq!(parse_Expr("(22)").unwrap(), expected);
        assert_eq!(parse_Expr("((((((22))))))").unwrap(), expected);
    }
    #[test]
    fn test_parsing_expressions() {
        let expected = Box::new(Expr::Binary(Box::new(Expr::Number(22)),
                                             Op::Plus,
                                             Box::new(Expr::Binary(
                                                 Box::new(Expr::Name(s("foo"))),
                                                 Op::Times,
                                                 Box::new(Expr::Number(2))))));
        assert_eq!(parse_Expr("22+foo*2").unwrap(), expected);
    }
    #[test]
    fn test_parsing_names() {
        let expected = Box::new(Expr::Name(s("foo")));
        assert_eq!(parse_Expr("foo").unwrap(), expected);
        assert_eq!(parse_Expr("(foo)").unwrap(), expected);
    }
    #[test]
    fn test_call_parsing() {
        let expected = Box::new(Expr::Call(Box::new(Expr::Name(s("foo"))), vec![]));
        assert_eq!(parse_Expr("foo()").unwrap(), expected);
        let expected = Box::new(Expr::Call(Box::new(Expr::Name(s("foo"))), vec![Box::new(Expr::Number(1))]));
        assert_eq!(parse_Expr("foo(1)").unwrap(), expected);
        let expected = Box::new(Expr::Call(Box::new(Expr::Name(s("foo"))), vec![Box::new(Expr::Number(1)),
                                                                     Box::new(Expr::Number(2)),
                                                                     Box::new(Expr::Number(3))]));
        assert_eq!(parse_Expr("foo(1, 2, 3)").unwrap(), expected);
        let expected = Box::new(Expr::Call(Box::new(Expr::Name(s("foo"))), vec![Box::new(Expr::Binary(Box::new(Expr::Number(1)), Op::Plus, Box::new(Expr::Number(2))))]));
        assert_eq!(parse_Expr("foo(1 + 2)").unwrap(), expected);
        let expected = Box::new(Expr::Call(Box::new(Expr::Name(s("foo"))), vec![Box::new(Expr::Binary(Box::new(Expr::Number(1)), Op::Plus, Box::new(Expr::Number(2)))),
                                                                     Box::new(Expr::Number(3))]));
        assert_eq!(parse_Expr("foo(1 + 2, 3)").unwrap(), expected);
        let expected = Box::new(Expr::Call(Box::new(Expr::Binary(Box::new(Expr::Number(1)), Op::Plus, Box::new(Expr::Number(2)))), vec![Box::new(Expr::Binary(Box::new(Expr::Number(1)), Op::Plus, Box::new(Expr::Number(2)))),
                                                                     Box::new(Expr::Number(3))]));
        assert_eq!(parse_Expr("(1 + 2)(1 + 2, 3)").unwrap(), expected);
    }
    #[test]
    fn test_lambda_parsing() {
        let expected = Box::new(Expr::Lambda(vec![s("x"), s("y")],
                                             Box::new(Expr::Binary(
                                                      Box::new(Expr::Name(s("x"))),
                                                      Op::Plus,
                                                      Box::new(Expr::Number(1)
                                                  )))));
        assert_eq!(parse_Expr(r"|x, y| -> (x + 1)").unwrap(), expected);
        let expected = Box::new(Expr::Lambda(vec![s("x")],
                                             Box::new(Expr::Binary(
                                                      Box::new(Expr::Name(s("x"))),
                                                      Op::Plus,
                                                      Box::new(Expr::Number(1)
                                                  )))));
        assert_eq!(parse_Expr(r"x -> (x + 1)").unwrap(), expected);
        assert_eq!(parse_Expr(r"|x| -> x + 1").unwrap(), expected);
    }
    #[test]
    fn test_pipe_parsing() {
        let expected = Box::new(Expr::Binary(
                            Box::new(Expr::Binary(
                                Box::new(Expr::Call(Box::new(Expr::Name(s("range"))), vec![Box::new(Expr::Number(10))])),
                                Op::Pipe,
                                Box::new(Expr::Call(Box::new(Expr::Name(s("map"))), vec![Box::new(Expr::Lambda(vec![s("x")], Box::new(Expr::Binary(Box::new(Expr::Name(s("x"))), Op::Times, Box::new(Expr::Name(s("x")))))))]))
                            )),
                            Op::Pipe,
                            Box::new(Expr::Call(Box::new(Expr::Name(s("foreach"))), vec![Box::new(Expr::Lambda(vec![s("x")], Box::new(Expr::Call(Box::new(Expr::Name(s("display"))), vec![Box::new(Expr::Name(s("x")))]))))]))));
        let got = parse_Expr(r"range(10) | map(x -> x * x) | foreach(x -> display(x))").unwrap();
        assert_eq!(got, expected);
    }
    #[test]
    fn test_assignment_parsing() {
        let expected = Box::new(Statement::Assignment(s("spam"), Box::new(Expr::Number(1))));
        let got = parse_Statement("spam := 1").unwrap();
        assert_eq!(got, expected);
    }
    #[test]
    fn test_push_parsing() {
        let expected = Box::new(Statement::Push(Box::new(Expr::Number(1))));
        let got = parse_Statement("push 1").unwrap();
        assert_eq!(got, expected);
    }
    #[test]
    fn test_block_parsing() {
        let expected = Box::new(Expr::Block(
                                vec![Box::new(Statement::Assignment(s("spam"), Box::new(Expr::Number(1)))),
                                     Box::new(Statement::Push(Box::new(Expr::Number(1))))]));
        let got = parse_Expr(r"{spam := 1; push 1}").unwrap();
        assert_eq!(expected, got);
    }
}
